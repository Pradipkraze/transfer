import rasterio
from rasterio.warp import calculate_default_transform, reproject, Resampling
from rasterio.merge import merge
import numpy as np

# Function to resample a raster to match the dimensions and resolution of another raster
def resample_raster(src_path, target_path, output_path):
    with rasterio.open(src_path) as src:
        with rasterio.open(target_path) as target:
            # Read the metadata of the target file
            transform, width, height = calculate_default_transform(
                src.crs, target.crs, target.width, target.height, *target.bounds
            )
            profile = src.profile.copy()
            profile.update({
                'crs': target.crs,
                'transform': transform,
                'width': width,
                'height': height
            })

            # Create the output file with updated profile
            with rasterio.open(output_path, 'w', **profile) as dst:
                for i in range(1, src.count + 1):
                    reproject(
                        source=rasterio.band(src, i),
                        destination=rasterio.band(dst, i),
                        src_transform=src.transform,
                        src_crs=src.crs,
                        dst_transform=transform,
                        dst_crs=target.crs,
                        resampling=Resampling.bilinear
                    )

# Function to create a new raster with updated dimensions
def create_new_dim_raster(src_path, reference_path, output_path):
    with rasterio.open(src_path) as src:
        with rasterio.open(reference_path) as ref:
            profile = ref.profile.copy()

            # Create the new raster with the reference dimensions and resolution
            with rasterio.open(output_path, 'w', **profile) as dst:
                data = src.read(out_shape=(src.count, ref.height, ref.width),
                                resampling=Resampling.bilinear)

                # Exclude nodata (assumed 0 by default)
                data[data == 0] = ref.nodata or 0
                dst.write(data)

# Function to create a mosaic
# Takes the value of image B for overlapping pixels, excluding 0 and nodata values
def create_mosaic(image_a_path, image_b_path, output_path):
    with rasterio.open(image_a_path) as img_a:
        with rasterio.open(image_b_path) as img_b:
            data_a = img_a.read()
            data_b = img_b.read()

            # Create an output mosaic where B values take precedence for overlaps
            mosaic = np.where(data_b != 0, data_b, data_a)

            # Use the metadata of the first image as the base profile
            profile = img_a.profile

            # Write the mosaic to a BigTIFF file
            profile.update(dtype='int16', BIGTIFF='YES')
            with rasterio.open(output_path, 'w', **profile) as dst:
                dst.write(mosaic)

# File paths
image_a_path = "image_a.tif"
image_b_path = "image_b.tif"
resampled_a_path = "A_resample.tif"
new_b_path = "B_new_dim.tif"
mosaic_path = "mosaic.tif"

# Resample image A to match the dimensions of image B
resample_raster(image_a_path, image_b_path, resampled_a_path)

# Create image B_new_dim.tif with the dimensions of A_resample.tif
create_new_dim_raster(image_b_path, resampled_a_path, new_b_path)

# Create the mosaic
create_mosaic(resampled_a_path, new_b_path, mosaic_path)
